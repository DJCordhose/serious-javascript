<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">

    <title>Serious JavaScript</title>

    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>

    <link rel="stylesheet" href="../reveal.js/css/reveal.min.css">
    <!--<link rel="stylesheet" href="../reveal.js/css/theme/simple.css" id="theme">-->
    <!--<link rel="stylesheet" href="../reveal.js/css/theme/sky.css" id="theme">-->
    <link rel="stylesheet" href="../reveal.js/css/theme/moon.css" id="theme">

    <!-- For syntax highlighting -->
    <!--<link rel="stylesheet" href="../reveal.js/lib/css/zenburn.css">-->
    <style>
        pre code {
            display: block;
            padding: 0.5em;
            background: #FFFFFF;
            color: #000000;
        }
    </style>

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <!--<script>-->
        <!--document.write('<link rel="stylesheet" href="../reveal.js/css/print/' + ( window.location.search.match(/print-pdf/gi) ? 'pdf' : 'paper' ) + '.css" type="text/css">');-->
    <!--</script>-->
    <!--<link rel="stylesheet" href="../reveal.js/css/print/pdf.css">-->

    <!--[if lt IE 9]>
    <script src="../reveal.js/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>

<div class="reveal">
<!-- JAX -->
<!--Sind ernsthafte JavaScript-Projekte möglich?-->

<!--Unabhängig von der steigenden Verbreitung von JavaScript, werden JavaScript-Projekten immer noch von manchen die-->
<!--Professionalität abgesprochen. Um das zu widerlegen, zeige ich in diesem Talk alle Werkzeuge, Techniken und-->
<!--Spracheigenschaften, die man braucht, um auch große und langlebige Projekte in JavaScript umzusetzen. Dazu gehören-->
<!--Modularisierung und Kapselung, Refactoring, Code-Analyse, statische Code-Checker und automatisierte Build-Prozesse und-->
<!--Tests.-->

<!-- enterJS -->
<!--Unabhängig von der steigenden Verbreitung von JavaScript wird JavaScript-Projekten häufig immer noch die-->
<!--Professionalität abgesprochen. Dieser Vortrag stellt alle Werkzeuge, Techniken und Spracheigenschaften vor, die man-->
<!--braucht, um auch große und langlebige Projekte in JavaScript umzusetzen und die Spötter so zu widerlegen. Methoden zur-->
<!--Modularisierung und Kapselung, Refactoring, Code-Analyse, statische Code-Checker und automatisierte Build-Prozesse-->
<!--sollen genauso Thema sein wie Tests.-->

<div class="slides">
<section>
    <h1>Ernsthaftes JavaScript</h1>
    <br>

    <h2>in Enterprise-Projekten</h2>
    <br>

    <h3>Aus der Perspektive eines Java-Entwicklers</h3>

    <p>
        <small><a target="_blank" href="http://zeigermann.eu">Oliver Zeigermann</a> / <a target="_blank" href="http://twitter.com/djcordhose">@DJCordhose</a>
        </small>
    </p>
    <p>Online version at: <a href="http://djcordhose.github.io/serious-javascript/slides/jax.html">http://djcordhose.github.io/serious-javascript/slides/jax.html</a></p>

</section>

<section>
    <img src="Twitter_2017_JavaScript.png">
</section>

<section>
    <h3>Was ist ein ernsthaftes Enterprise-Projekt?</h3>
    <ul>
        <li class="fragment">es ist unternehmenskritisch, d.h. der Erfolg des Unternehmens ist davon abhängig
        <li class="fragment">lebt für viele Jahre
        <li class="fragment">ist ein unendliches Spiel (im Gegensatz zu einem endlichen Spiel in der Spieltheorie)
        <li class="fragment">es gibt ein Team (mehr als ein Mitglied)
        <li class="fragment">es gibt kein konstantes Team, Mitglieder kommen und gehen
    </ul>
</section>

<!-- Aufbau -->
<!-- Wartbarkeit -->
<!-- Skalierbarkeit -->
<!-- Frameworks -->
<!--Letzter Punkt:,wie weit gehen? Polyglott vs. node / Avatar.js-->
<section>
    <h2>JavaScript-Projekte</h2>
    <ol>
        <!-- Frischer Anfang gleich mit viel Code -->
        <li class="fragment">haben keine Struktur und sind Chaos <!-- Aufbau -->
            <!-- Lockere Übersicht über Frameworks  -->
        <li class="fragment">sind allein schon wegen der Ablaufumgebung (Browser) der Horror <!-- Frameworks -->
            <!-- Der Fleißteil -->
        <li class="fragment">sind von Anfang an unwartbar ... <!-- Wartbarkeit -->
        <li class="fragment" value="3">... und können nur im kleinen Rahmen funktionieren
            <!-- Module, Klassen, Abhängigkeitsmanagement, AMD, CommonJS -->
            <!-- Der spannende und wohl neue Teil -->
        <li class="fragment">erfordern in jedem Fall eine polyglotte Programmierung <!-- Node.js, Nashorn, Avatar.js -->
    </ol>
    <p></p>

    <h3 class="fragment">Stimmt das? Oder sind das Vorurteile?</h3>

    <p class="fragment">Die Untersuchung ist Gegenstand dieser Session</p>
</section>

<!--<section>-->
    <!--<h2>Oliver Zeigermann</h2>-->
    <!--<img src="olli.jpg" height="200">-->
    <!--<ul>-->
        <!--<li><a target="_blank" href="http://zeigermann.eu">http://zeigermann.eu</a>-->
        <!--<li><a target="_blank" href="https://twitter.com/DJCordhose">@DJCordhose</a>-->
        <!--<li><a target="_blank" href="https://github.com/DJCordhose">https://github.com/DJCordhose</a>-->
        <!--<li><a target="_blank" href="http://javatojavascript.blogspot.de/">javatojavascript.blogspot.de</a>-->
        <!--<li><a target="_blank" href="http://entwickler.de/press/JavaScript-fuer-Java-Entwickler">JavaScript für-->
            <!--Java-Entwickler</a>-->
    <!--</ul>-->
<!--</section>-->
<section>
    <section>
        <h2>Aufbau moderner Webanwendungen</h2>

        <p>So sieht eine moderne 08/15 Webanwendung aus</p>

        <p>Erzeugt mit <a target="_blank" href="http://yeoman.io/">http://yeoman.io/</a></p>

        <p class="fragment">Untersuchung der Frage: Haben JavaScript-Projekte keine Struktur und sind Chaos?</p>
    </section>

    <section>
        <h3>Live-Demo: Eine komplette Webanwendung</h3>
        <ul>
            <!-- Jeden einzelnen Punkt am Projekt zeigen -->
            <li class="fragment"><code>yo webapp</code>
            <li class="fragment">IDE: WebStorm
            <li class="fragment">Grunt.js: Build-Tool
            <li class="fragment">Bower: Abhängigkeitsmanagement
            <li class="fragment">Comapss und SASS: Abstraktion von CSS
            <li class="fragment">Mocha / Chai: BDD-/Unit-Test-Framework
            <li class="fragment">JsHint: Linter
        </ul>
    </section>

    <!-- Jeden einzelnen Punkt am Projekt zeigen -->
    <!--<section>-->
        <!--<h3>Live-Demo: Eine komplette AngularJS-Anwendung</h3>-->
        <!--<ul>-->
            <!--<li class="fragment"><code>yo angular</code>-->
            <!--<li class="fragment">Angular-->
            <!--<li class="fragment">Karma: Test-Runner mit WebStorm-Integration-->
            <!--<li class="fragment">PhantomJS-->
            <!--<li class="fragment">Jasmine: BDD-/Unit-Test-Framework-->
            <!--<li class="fragment">Angular-Scenario: E2E-Test-Framework-->
        <!--</ul>-->
    <!--</section>-->

</section>

<section>
    <h1>Fragen?</h1>
</section>

<section>
    <section>
        <h2>Node.js und Avatar.js</h2>

        <p class="fragment">Untersuchung der Frage: Erfordern JavaScript-Projekte in jedem Fall eine polyglotte
            Programmierung?</p>
    </section>

    <!-- Node.js, Nashorn, Avatar.js -->

    <!--Letzter Punkt:,wie weit gehen? Polyglott vs. node / Avatar.js-->

    <section>
        <h3>Fragestellung</h3>
        <ul>
            <li class="fragment">JavaScript im Browser ist als Zielsprache gesetzt
            <li class="fragment">Meist braucht man auch Code, der auf dem Server läuft
            <li class="fragment">Wie setzt man diesen um?
            <li class="fragment">JEE/Spring/.NET/Rails/Python?
            <li class="fragment">Oder ebenfalls in JavaScript?
        </ul>
    </section>

    <section>
        <h3>JavaScript auch auf dem Server?</h3>
        <ul>
            <li class="fragment">Code kann wieder verwendet werden
            <li class="fragment">Dieselben Tools für Frontend und Backend
            <li class="fragment">Kleinerer Technologiestack
            <li class="fragment">Vertikale Teams einfacher zu realisieren
            <li class="fragment">Einheitliche Entwicklungsphilosophie
            <li class="fragment">JSON als natürliches Datenformat
        </ul>
    </section>
    <section>
        <h3>Node.js</h3>
        <ul>
            <li class="fragment">Erlaubt die Ausführung von JavaScript auch auf dem Server
            <li class="fragment">Bestandteile
                <ul>
                    <li class="fragment">Chrome V8 JavaScript-Engine
                    <li class="fragment">Asynchrone IO-Bibliothek (libuv), die auf allen Plattformen läuft
                </ul>
            </li>
            <li class="fragment">Asynchrones Programmiermodell, kein Multithreading
            <li class="fragment">Forken für Auslastung alles Kerne mit <a target="_blank"
                                                                          href="http://nodejs.org/api/cluster.html">"Clustering"
                als Kernmodul</a>

            <li class="fragment"><a target="_blank" href="http://cjihrig.com/blog/scaling-node-js-applications/">Skalierung
                über viele Maschinen</a> möglich
            <li class="fragment">Skaliert sehr gut bei hoher Last (non-blocking)
            <!--<li class="fragment">Express als Modul für klassische Webanwendungen-->
            <!--<li class="fragment">Auch ideal als API-Server-->
        </ul>
    </section>
    <section>
        <h3>Beispiel-Server für node</h3>
<pre><code class="javascript" contenteditable>var http = require('http');

function handleRequest (req, res) {
    res.writeHead(200, {'Content-Type': 'text/plain'});
    res.end('Hello World\n');
}
http.createServer(handleRequest).listen(1337);</code></pre>
        <p class="fragment">Starten</p>
        <pre class="fragment"><code class="javascript" contenteditable>node server.js</code></pre>
    </section>

    <section>
        <h3>Wer nutzt Node.js in Produktion?</h3>
        <ul>
            <li class="fragment"><a target="_blank"
                                    href="https://www.paypal-engineering.com/2013/11/22/node-js-at-paypal/">Paypal</a>
            <li class="fragment"><a target="_blank"
                                    href="http://venturebeat.com/2012/01/24/why-walmart-is-using-node-js/">Walmart</a>
            <li class="fragment"><a target="_blank"
                                    href="http://www.ebaytechblog.com/2013/05/17/how-we-built-ebays-first-node-js-application/#.U0ZFXK2Sxwg">Ebay</a>
            <li class="fragment"><a target="_blank" href="http://venturebeat.com/2011/08/16/linkedin-node/">Linkedin</a>
            <li class="fragment"><a target="_blank"
                                    href="https://github.com/joyent/node/wiki/Projects,-Applications,-and-Companies-Using-Node">Viele
                weitere</a>
            <li class="fragment"><a target="_blank" href="http://nodejs.org/industry/">Node.js-Unterstützer</a>
        </ul>
    </section>

    <section>
        <h3>Umstellung auf Node.js? Aber:</h3>
        <ul>
            <li class="fragment">Legacy code?
            <li class="fragment">Nur ein Teil soll auf Node.js umgestellt werden?
            <li class="fragment">Schrittweise Umstellung?
            <li class="fragment">JavaScript hat nur "number". Wie sieht es mit Geld-Berechnungen aus?
        </ul>
    </section>

    <section>
        <h3>JDK 8 Nashorn</h3>
        <ul>
            <li class="fragment">JDK 8 hat eine neue JavaScript-Engine: Nashorn
            <li class="fragment">Ersetzt Rhino
            <li class="fragment">ECMAScript 5.1-Kompatibel
            <li class="fragment">Übersetzt JavaScript in Java Bytecode
            <li class="fragment">Deutlich schneller als Rhino bei länger laufenden Tasks (Server)
            <li class="fragment">Zugriff auf Java-Klassen (BigDecimal!) und SAM types von JavaScript sehr einfach
        </ul>
    </section>
    <section>
        <h3>Beispiel-Code Nashorn mit Java-Integration</h3>
<pre><code class="javascript" contenteditable>var BigDecimal = Java.type('java.math.BigDecimal');

function calculatePercentage(amount, percentage) {
    var result = new BigDecimal(amount).multiply(
       new BigDecimal(percentage)).divide(new BigDecimal('100'),
        2, BigDecimal.ROUND_HALF_EVEN);
    return result.toPlainString();
}
</code></pre>
        <p class="fragment">Ja, das ist JavaScript-Code</p>
    </section>


    <section>
        <h3>Avatar.js</h3>
        <ul>
            <li class="fragment">Bietet das Node.js Programmiermodell für Java und Nashorn
            <li class="fragment">Core-Pakete und alle wichtigen Module laufen
            <li class="fragment">Start aus Java heraus möglich
            <li class="fragment">Threading für JavaScript möglich
            <li class="fragment">Aufruf beliebiger Java-Services (Legacy) aus JavaScript
        </ul>
    </section>
</section>

<section>
    <h1>Fragen?</h1>
</section>

<!--Code Qualität / Refactorbarkeit / Wartbarkeit: JsHint, TypeScript, Closure-->

<section>
    <section>
        <h2>Code Qualität, Module, statische Analyse</h2>

        <p class="fragment">Untersuchung der Fragen: Sind JavaScript-Projekte von Anfang an unwartbar und können nur im
            kleinen Rahmen funktionieren?</p>

        <h3 class="fragment">Provokantere Frage: Selbst wenn ich schnell in JavaScript entwickeln kann, wird mein Code
            in einem Jahr noch wartbar sein?</h3>
        <h4 class="fragment">Und in 5 Jahren?</h4>
        <h5 class="fragment">Und in 10 Jahren?</h5>
    </section>

    <!--Code Qualität / Refactorbarkeit / Wartbarkeit: JsHint, TypeScript, Closure-->
    <!--Test-Frameworks-->
    <!-- Module, Klassen, Abhängigkeitsmanagement, AMD, CommonJS -->
    <section>
        <h3>Fragestellungen der Wartbarkeit</h3>
        <ul>
            <li class="fragment">Wie modularisiere ich meinen Code, um
                <ul>
                    <li class="fragment">ihn handhabbar zu halten
                    <li class="fragment">mit mehreren Entwicklern daran arbeiten zu können
                </ul>
            </li>
            <li class="fragment">Wie halte ich meinen Code einfach lesbar?
            <li class="fragment">Wie definiere ich ein Maß für Code-Qualität und wie erreiche ich diese?
            <li class="fragment">Wie ermögliche ich eine statische Analyse?
            <!--<li class="fragment">Wie teste ich meinen Code?-->
            <!-- Ist schon im ersten Teil beantwortet -->
            <!--<li class="fragment">Wie automatisiere ich Analyse und Test?-->
                <!--

                Paypal and Walmart use node and are really fast. But, will it be
                maintainable in 1 year and in 5 years?
                 -->

        </ul>
    </section>

    <section>
        <h2>Muster für größere Projekte</h2>
    </section>
    <section>
        <h2>Erfahrung: Module und Typen-Hierarchien fördern strukturiertes Arbeiten</h2>
    </section>
                <!--<section>-->
                    <!--<h3>this in Objekten</h3>-->
                    <!--<ul>-->
                        <!--<li class="fragment">Objekte können auch Funktionen als Properties haben-->
                        <!--<li class="fragment">Diese funktionieren dann wie Methoden, d.h. <code>this</code> ist an das Objekt gebunden über das sie aufgerufen werden-->
    <!--<li class="fragment"><pre><code class="javascript" contenteditable>var obj = {-->
    <!--field: 10,-->
    <!--log: function() {-->
        <!--console.log(this.field);-->
    <!--}-->
<!--};-->

<!--obj.log(); // 10-->
    <!--</code></pre>-->
                    <!--</ul>-->
                <!--</section>-->
                <!--<section>-->
                    <!--<h3>Singleton</h3>-->
                    <!--<ul>-->
                        <!--<li class="fragment">Wie gesehen, kann man in JavaScript Objekte auch ohne einen Typ erzeugen-->
                        <!--<li class="fragment">In klassenbasierten Sprachen muss man auch dafür einen Typ erzeugen und darauf achten, dass man nur eine Instanz erzeugen kann-->
                        <!--<li class="fragment">Das Pattern dazu heißt <code>Singleton</code>-->
                        <!--<li class="fragment">In JavaScript braucht man dieses Pattern nicht-->
                        <!--<li class="fragment">Manchmal möchte man allerdings auch mehrere Objekte mit dergleichen oder ähnlichen Struktur erzeugen-->
                    <!--</ul>-->
                <!--</section>-->
    <section>
        <h2>Klassische Typen und Vererbung mit JavaScript</h2>
        <ul>
            <li class="fragment">Typen und Konstruktoren sind Mechanismen, um mehrere, strukturell gleiche oder ähnliche Objekte zu erzeugen
            <li class="fragment">Auch in JavaScript können eigene Typen definiert werden
            <li class="fragment">Einfachvererbung ist ebenso möglich
            <li class="fragment">Der Mechanismus ist nicht direkt in die Sprache eingebaut
            <li class="fragment">Stattdessen benutzen wir Best-Practice-Patterns
            <li class="fragment">Grundlage ist die prototypische Vererbung
        </ul>
    </section>
            <section>
                <h2>Setzen des Prototypen aka das Typen-System</h2>
                <p>Typen werden über Konstruktor-Funktionen definiert</p>
    <pre class="fragment"><code class="javascript" contenteditable>/** @constructor */
function Person(name) {
    this.name = name;
}
Person.prototype.getName = function() {
    return this.name;
};</code></pre>
    <pre><code class="javascript" contenteditable>var olli = new Person('Olli');
olli.getName() === 'Olli';</code></pre>
            </section>

    <section>
        <h2>Modularisierung</h2>
        <!--<ul>-->
            <!--<li class="fragment">Revealing Module Pattern: Sichtbarkeit-->
            <!--<li class="fragment">AMD und RequireJS: Externe Abhängigkeiten, asynchron-->
            <!--<li class="fragment">CommonJS und Browserify: Externe Abhängigkeiten, synchron-->
        <!--</ul>-->
    </section>
    <section>
        <h3>Revealing Module Pattern</h3>
<pre class="fragment"><code class="javascript" contenteditable>var person = {};
</code></pre>
<pre class="fragment"><code class="javascript" contenteditable>(function () {
    // Constructor
    function Person(name) {
        this.name = name;
    }

    // Factory
    function create(name) {
        return new Person(name);
    }

    // Export der Factory-Methode
    person.createPerson = create;
})();
</code></pre>
<pre class="fragment"><code class="javascript" contenteditable>var olli = person.createPerson('Olli');</code></pre>
        </code></pre>

    </section>

    <section>
        <h3>Es gibt zwei grundsätzlich unterschiedliche Modul-Systeme als Defacto-Standard</h3>
        <ul>
            <li class="fragment">AMD
                <ul>
                    <li class="fragment">Module werden nicht blockierend und potentiell asynchron geladen
                    <li class="fragment">Module werden über bower oder manuell installiert
                    <li class="fragment">Verwendung auf Client-Seite
                    <li class="fragment">Default-Implementierung: RequireJS
                    <!--<li class="fragment">Für blockierendes Laden auf Server-Seite: r.js-->
                </ul>
            </li>
            <li class="fragment">CommonJS
                <ul>
                    <li class="fragment">Module werden blockierend und synchron geladen
                    <li class="fragment">Module werden über npm installiert
                    <li class="fragment">Verwendung auf Server-Seite
                    <!--<li class="fragment">Für nicht blockierendes Laden auf Client-Seite: Browserify-->
                </ul>
            </li>
            <li class="fragment">Beide Modul-Systeme können über r.js / Browserify auch auf Server / Client benutzt werden
        </ul>
    </section>
    <!-- Jeden einzelnen Punkt am Projekt zeigen -->
    <!--<section>-->
        <!--<h3>Live-Demo: Eine komplette Browserify-Anwendung</h3>-->
        <!--<p class="fragment">Anwendung für den Client mit CommonJS</p>-->
        <!--<p class="fragment">Browserify erzeugt eine einzige Datei aus allen Modulen</p>-->
        <!--<p class="fragment">Diese werden dann zwar immer noch synchron geladen, aber ohne merklich Verzögerung</p>-->
        <!--<ul>-->
            <!--<li class="fragment"><code>yo browserify</code>-->
            <!--<li class="fragment">Gulp.js: Build-Tool mit Stream-Support-->
            <!--<li class="fragment">Uglify: Minifiy / Obfuscate-->
            <!--<li class="fragment">Browserify erzeugt eine einzige Datei aus allen Modulen-->
            <!--<li class="fragment"><a target="_blank" href="http://foundation.zurb.com/">Foundation</a>: Responsive Layout-->
            <!--<li class="fragment">Jade: Serverseitige Templates-->
        <!--</ul>-->
    <!--</section>-->
    <section>
        <h3>Deklarierte Typen</h3>
        <ul>
        <li class="fragment">Grundlage der Überlegung
            <ul>
                <li class="fragment">Verlässliche Toolunterstützung für Analyse und Refactoring sind ohne statische Typ-Information nicht möglich
                <li class="fragment">Ohne verlässliche Analyse- und Refactoring-Möglichkeiten wird Enterprise-Code schnell untwartbar
            </ul>
        </li>
            <li class="fragment">Mögliche Techniken
                <ul>
                    <li class="fragment">Google Closure Compiler
                    <li class="fragment">TypeScript
                        <!--<li class="fragment">Esprima-->
                </ul>
            </li>
        </ul>
    </section>
    <section>
        <h3>Google Closure Compiler</h3>
        <ul>
            <li class="fragment">Statisch deklarierte Typ-Information werden in Kommentaren angegeben
            <li class="fragment">Erweiterung von JSDoc
            <li class="fragment">Compiler nutzt Typ-Information für statische Checks und optimierten Code
            <li class="fragment"><a target="_blank" href="https://developers.google.com/closure/compiler/">Hauptseite des Compilers</a>
            <li class="fragment"><a target="_blank" href="https://developers.google.com/closure/library/">Module funktionieren über die Closure Library</a>
        </ul>
    </section>
        <section>
        <h3>Beispiel-Code: Interface</h3>
<pre><code class="javascript" contenteditable>/**
 *
 * @interface
 */
function HasName() { }

/**
 * @returns {string}
 */
HasName.prototype.getName = function() {};
</code></pre>
    </section>

        <section>
        <h3>Beispiel-Code: Class</h3>
<pre><code class="javascript" contenteditable>/**
 *
 * @param name {string}
 * @param alter {number}
 * @param geschlecht {string=}
 * @constructor
 * @implements {HasName}
 */
function Person(name, alter, geschlecht) {
    this.name = name;
    this.alter = alter;
    this.geschlecht = geschlecht;
}
</code></pre>
    </section>

    <section>
        <h3>Google Closure Compiler: Bewertung</h3>
        <ul>
            <li class="fragment">Vorteile
                <ul>
                    <li class="fragment">Lesbarkeit für Menschen verbessert
                    <li class="fragment">Verbesserter IDE-Support durch deklarierte Typen
                    <li class="fragment">Kein Compilierungsschritt zur Ausführung notwendig
                    <li class="fragment">Compiler nutzt Typ-Informationen auch zur Optimierung
                </ul>
            </li>
            <li class="fragment">Nachteile
                <ul>
                    <li class="fragment">Technologie-Stack wächst
                    <li class="fragment">Es sieht nicht sonderlich schön aus
                    <li class="fragment">Abhängigkeit von Google-Technologie (Rückkehr zu einfach JavaScript möglich)
                    <li class="fragment">JavaScript-Konstrukte (z.B. für Interfaces oder Varargs) teilweise etwas überraschend
                </ul>
            </li>
        </ul>
    </section>
    <section>
        <h3>TypeScript</h3>
        <ul>
            <li class="fragment">Mehr oder weniger ECMAScript 6 mit optionalen deklarierten Typen
            <li class="fragment">Compiliert zu JavaScript, das man so auch von Hand schreiben würde
            <li class="fragment"><a target="_blank" href="http://www.typescriptlang.org/Playground/">TypeScript-Playground</a>
            <li class="fragment">Externe Deklarationen erlauben nachträgliche Typisierung von existierendem JavaScript-Code
            <li class="fragment"><a target="_blank" href="https://github.com/borisyankov/DefinitelyTyped">Externe
                Deklarationen für sehr viele JavaScript-Biblitotheken</a>
            <li class="fragment"><a target="_blank" href="http://channel9.msdn.com/Events/Build/2014/3-576">Talk zum 1.0
                Release von Anders Hejlsberg</a>
        </ul>
    </section>
            <section>
        <h3>Beispiel-Code</h3>
<pre><code class="java javascript" contenteditable>interface HasName {
    getName(): string;
}

class Person implements HasName {
    constructor(private name: string, private alter: number,
    private geschlecht: string = 'F') {
    }
    getName() {
        return this.name;
    }
}

var olli: HasName = new Person('Olli', 43);</code></pre>
    </section>

    <section>
        <h3>TypeScript: Bewertung</h3>
        <ul>
            <li class="fragment">Vorteile
                <ul>
                    <li class="fragment">Lesbarkeit für Menschen verbessert
                    <li class="fragment">Stark verbesserter IDE-Support durch deklarierte Typen
                    <li class="fragment">Typinformation sogar für JSON-Objekte
                </ul>
            </li>
            <li class="fragment">Nachteile
                <ul>
                    <li class="fragment">Technologie-Stack wächst
                    <li class="fragment">Compilierungsschritt immer notwendig
                    <li class="fragment">Abhängigkeit von MicroSoft-Technologie (Rückkehr zu JavaScript möglich)
                    <li class="fragment">Optionale Typen erfordern viel Eigenverantwortung der Entwickler
                </ul>
            </li>
        </ul>
    </section>

    <!--<section>-->
        <!--<h3>Esprima: TODO</h3>-->
        <!--<ul>-->
            <!--<li class="fragment">-->
        <!--</ul>-->
    <!--</section>-->

    <section>
        <h2>Code Qualität mit JSHint</h2>
        <ul>
            <li class="fragment">Analysiert JavaScript-Files und macht konfigurierbare Prüfungen
            <li class="fragment"><a target="_blank" href="http://www.jshint.com/about//">http://www.jshint.com/</a>
            <li class="fragment">Deckt potentielle Fehler auf
            <li class="fragment">Kann die Code-Conventions des Teams unterstützen
        </ul>
    </section>
    <section>
        <h3>Was könnten hier die Probleme sein?</h3>
<pre class="fragment"><code class="javascript" contenteditable>function olli() {
    console.log("aha")
    func();
    variable = 10;
 var myVar;
    10 == "10";
    if (true) console.log('Yo');
}</code></pre>
        <ul>
            <li class="fragment">Aufruf von der Kommandozeile oder IDE-Integration
            <li class="fragment">Anhand eine Konfigurationsfiles können <em>alle</em> Optionen an oder ausgeschaltet bzw. konfiguriert werden
            <li class="fragment">In jeder JavaScript-Datei können zudem Warnungen ausgeschaltet werden (vgl. @SuppressWarnings in Java)
        </ul>

    </section>
</section>

<section>
    <h1>Fragen?</h1>
</section>

<section>
    <section>
        <h2>Browser-Frameworks</h2>

        <p class="fragment">Untersuchung der Frage: Sind JavaScript-Projekte allein schon wegen der Ablaufumgebung
            (Browser) der Horror?</p>
    </section>
    <section>
        <h3>Wozu ein Framework für die Browser-Entwicklung?</h3>
        <ul>
            <li class="fragment">Es gibt immer noch eine Reihe von Browser-Unterschieden bzgl. DOM und JavaScript (insbesondere
                pre IE9)
            <li class="fragment">Das DOM ist kein "ideales" API
            <li class="fragment">Selbst idealerweise ist das DOM immer noch sehr low-level
            <!--<li class="fragment">Angemessenes UX-->
            <li class="fragment">Unterstützung unterschiedlicher Gerätekonzepte und Gerätegrößen
        </ul>
    </section>
    <section>
        <h3>Anforderungen an ein Browser-Framework für Enterprise-Projekte</h3>
        <ul>
            <li class="fragment">Es muss zu meiner Anwendung passen
                <ul>
                    <li class="fragment">Business-Anwendung?
                    <li class="fragment">Soll auf mobilen Geräten laufen?
                    <li class="fragment">Grafisch sehr ansprechend?
                    <li class="fragment">Leichte Bedienung? (Business-User vs. Casual)
                </ul>
            <li class="fragment">Es muss über viele Jahre gewartet bleiben
            <li class="fragment">Rückwärtskompatibilität
            <li class="fragment">Es muss leicht erlernbar sein
        </ul>
    </section>
    <!--<section>-->
        <!--<img src="Twitter_Lang_Community.jpg" height="600">-->
        <!--<p><a target="_blank" href="https://twitter.com/kilaulena/status/463317989648248832">https://twitter.com/kilaulena/status/463317989648248832</a></p>-->
    <!--</section>-->
    <section>
        <h3>Kultur-Clash Java- / JavaScript-Frameworks</h3>
        <ul>
            <li class="fragment">kleinere Module dominieren die JavaScript-Framework-Welt
                <ul>
                    <li class="fragment">npm und bower mit anarchischer Organisationsstruktur
                    <li class="fragment">Wenn überhaupt dann Defacto-Standards
                    <li class="fragment">Jeder muss sich seinen eigenen Satz an Komponenten auswählen
                    <li class="fragment">u.a. yeoman und Bootstrap-Pakete geben zumindest etwas Richtung
                </ul>
            </li>
            <li class="fragment">Java kommt mit komplettem JDK und JEE-Standard
                <ul>
                    <li class="fragment">bietet Orientierung
                    <li class="fragment">allerdings auch weniger Freiheit (bzw. andere Auswahl muss auch vertreten
                        werden)
                </ul>
            </li>
        </ul>
    </section>
        <section>
        <h3>Auswahl von Frameworks, die sich als Enterprise-würdig erwiesen haben</h3>
        <ul>
            <li class="fragment">jQuery
            <li class="fragment">AngularJS
            <!--<li class="fragment">React-->
            <li class="fragment">Ext.js
            <li class="fragment">Kein Framework
        </ul>
    </section>

    <section>
        <h2>Zum Vergleich: Hello World ohne Framework</h2>
        <pre><code class="xml" contenteditable>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Hello World!&lt;/title&gt;
  &lt;/head&gt;
    &lt;body&gt;
      &lt;div id="log">&lt;/div>
      &lt;script&gt;
          var element = document.getElementById("log");
          element.innerHTML = "&lt;h1>Hello World&lt;/h1>";
      &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
                        </code></pre>
                        <a href="../HelloWorld/helloworld2.html" target="_blank">Run</a>
                    </section>

    <section>
        <h3>Option: jQuery</h3>
        <ul>
            <li class="fragment">Standard-JavaScript-Bibliothek
            <li class="fragment">Fast überall zu finden
            <li class="fragment">Adressiert Probleme bei der Programmierung des DOMs
            <li class="fragment">Abstrahiert nicht von der Ebene der DOM-Manipulation
            <!--<li class="fragment">Flexible Trennung von View und Logik-->
            <li class="fragment">Funktionalität unterteilbar in "Auswahl" und "Manipulation"
            <!--<li class="fragment">Core, UI und Mobile Bibliothek vorhanden-->
            <!--<li class="fragment">Viele Plugins vorhanden,-->
                <!--z.B. <a target="_blank" href="http://sorgalla.com/jcarousel/">jcarousel</a>-->
        </ul>
    </section>
    <section>
        <h2>Hello World jQuery</h2>
        <pre><code class="xml" contenteditable>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Hello World jQuery!&lt;/title&gt;
    &lt;body&gt;
      &lt;div id="log">&lt;/div>
      &lt;script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.0/jquery.min.js">&lt;/script>

      &lt;script&gt;
        $(document).ready(function(){
            $("#log").html("&lt;h1>Hello World&lt;/h1>");
        });
      &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
                        </code></pre>
                        <a href="../HelloWorld/helloworld-jQuery.html" target="_blank">Run</a>
                    </section>

    <section>
        <h3>Option: AngularJS</h3>
        <h4>HTML enhanced for web apps!</h4>
        <img src="angular.png">
        <p><a target="_blank" href="http://angularjs.org/">http://angularjs.org</a></p>
    </section>
    <section>
        <h3>Konzepte</h3>
        <ul>
            <li class="fragment">Client-Seitige Templates
            <li class="fragment">MVC (Modell ist eher ViewModel)
            <li class="fragment">Die drei Ds
                <ul>
                    <li class="fragment">Data Binding
                    <li class="fragment">Dependency Injection
                    <li class="fragment">Directives
                </ul>
        </ul>
    </section>

    <section>
                    <h3>Hello World AngularJS</h3>
<pre><code class="xml" contenteditable>&lt;html ng-app>
&lt;head>
    &lt;script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.2.11/angular.min.js">&lt;/script>
    &lt;script src="controller.js">&lt;/script>
&lt;/head>
&lt;body ng-controller="HelloController">
    &lt;input ng-model="greeting">
    &lt;p>{{greeting}}, World!&lt;/p>
&lt;/body>
&lt;/html></code></pre>
<pre><code class="javascript" contenteditable>function HelloController($scope) {
    $scope.greeting = 'Hello';
}</code></pre>
        <a href="../HelloWorld/helloWorldAngular2.html" target="_blank">Run</a>
                </section>

    <!--<section>-->
        <!--<h3>Option: React</h3>-->
            <!--<ul>-->
                <!--<li class="fragment">Framework von Facebook und Instagram-->
                <!--<li class="fragment">Nur das V in MVC-->
                <!--<li class="fragment">Templates können in reinem JavaScript oder mit der Template-Sprache JSX geschrieben werden-->
                    <!--<ul>-->
                        <!--<li class="fragment">JSX kann "on the fly" gerendert oder-->
                        <!--<li class="fragment">für Produktion nach JavaScript vorkompiliert werden-->
                    <!--</ul>-->
                <!--</li>-->
                <!--<li class="fragment">Basiert auf Komponenten-->
                <!--<li class="fragment">der View wird als "virtuelles DOM" repräsentiert-->
                <!--<li class="fragment">Änderungen des Modells führen automatisch zum Neurendern von Komponenten-->
                <!--<li class="fragment">Ein schlauer Algorithmus macht minimale Änderungen am eigentlich DOM => schnell-->
                <!--<li class="fragment">React läuft im Browser und auf dem Server-->
            <!--</ul>-->
        <!--</section>-->

            <!--<section>-->
            <!--<h3>Hello World React</h3>-->
<!--<pre><code class="html" contenteditable>&lt;div id="example">&lt;/div>-->
<!--&lt;script type="text/jsx">-->
<!--/** @jsx React.DOM */-->
<!--var mountNode = document.getElementById('example');-->
<!--var HelloMessage = React.createClass({-->
  <!--render: function() {-->
    <!--return &lt;div>Hello {this.props.name}&lt;/div>;-->
  <!--}-->
<!--});-->

<!--React.renderComponent(&lt;HelloMessage name="Olli" />, mountNode);-->
<!--&lt;/script></code></pre>-->
                <!--<a href="../HelloWorld/helloWorldReact.html" target="_blank">Run</a>-->
            <!--<ul>-->
                <!--<li class="fragment"><code>React.createClass</code>: Erzeugt eine neue Komponenten-Klasse-->
                <!--<li class="fragment"><code>render</code>: erzeugt das virtuelle DOM-->
                <!--<li class="fragment"><code>this.props</code> / input: Parameter für die Komponentnen-Instanz-->
            <!--</ul>-->
        <!--</section>-->

    <!-- Jeden einzelnen Punkt am Projekt zeigen -->
    <!--<section>-->
        <!--<h3>Live-Demo: React.js mit RequireJS</h3>-->
        <!--<ul>-->
            <!--<li class="fragment"><code>yo react</code>-->
            <!--<li class="fragment">Modul-Definition und Abhängigkeitsauflösung mit requireJs-->
            <!--<li class="fragment">Einfache JSX basierte React-Anwendung-->
        <!--</ul>-->
    <!--</section>-->

    <section>
        <h3>Option: ExtJs</h3>
        <ul>
            <li class="fragment">hat alle Komponenten für eine Business-Anwendung
            <li class="fragment">folgt weniger der Web-Philosophy als der Desktop-Metapher
            <li class="fragment"><a target="_blank"
                                    href="http://www.sencha.com/blog/announcing-public-beta-of-ext-js-5/">ExtJS 5</a>
                unterstützt alle Devices
            <li class="fragment">Unterstützt weiterhin IE8
            <li class="fragment">Unterschiedliche Themes durch austauschen von CSS
            <li class="fragment">existiert seit vielen Jahren, Einsatz kommerziell
        </ul>
    </section>
    <section>
    <h3>Hello World ExtJS</h3>
<pre><code class="javascript" contenteditable>Ext.application({
    name: 'Hello World',

    launch: function() {
        Ext.create('Ext.container.Viewport', {
            layout: 'fit',
            items: [
                {
                    xtype: 'panel',
                    title: 'Hello World',
                    html : 'Hello!'
                }
            ]
        });
    }
});</code></pre>
    <a href="../HelloWorld/helloWorldExtjs.html" target="_blank">Run</a>

                    </section>


    <section>
        <h3>Letzte Option: Kein Framework</h3>
        <ul>
            <li class="fragment">Was ist die Motivation?
            <li class="fragment">Passt keines der Frameworks zu den Anforderungen?
            <li class="fragment">Selbstbetrug ausschließen: Bauen wir uns nicht unser eigenes Framework?
            <li class="fragment">Glauben wir wirklich, dass unser eigenes Framework besser sein wird als ein
                Standard-Framework?
            <li class="fragment">Wenn ja, wer in dem Team hat schon einmal ein vergleichbares Framework gebaut?
        </ul>
    </section>

    <section>
        <h3>Wrapup</h3>
        <ul>
            <li class="fragment">Kein Framework: Gängige Frameworks passen nicht oder Anwendung ist sehr einfach
            <li class="fragment">jQuery: DOM als Abstraktion ist ausreichend, Projekt evtl. nicht sehr komplex
            <li class="fragment">Angular.js: Sehr praktisch für SPAs und größere Projekte
            <li class="fragment">Ext.js: Für Business-Anwendungen, wie man sie auch mit JSF oder JavaFX bauen würde
        </ul>
    </section>
</section>

<section>
    <h1>Fragen?</h1>
</section>

<!--<section>-->
    <!--<h2>Weitere Fragestellungen</h2>-->
    <!--<p class="fragment">Mit JavaScript ...</p>-->
    <!--<ul>-->
        <!--<li class="fragment">... reactive MicroServices als Big Data im elastischen Hadoop Cluster als IoT-->
        <!--<li class="fragment">Mit DevOps mobil deployen-->


    <!--</ul>-->
<!--</section>-->

<section>
    <h2>Was haben wir gesehen?</h2>
    <ul>
        <li class="fragment">Es gibt brauchbare Strukturen, Prozesse und Tools für JavaScript-Projekte
        <li class="fragment">Gute Frameworks machen das DOM und die Browser-Vielfalt erträglich
        <li class="fragment">Die Sprache JavaScript und Werkzeuge um die Sprache herum ermöglichen Wartbarkeit auch für
            große Projekte
        <li class="fragment">JavaScript ist auf Client und auf Server möglich
    </ul>
</section>
<section>
    <h2>Allerdings</h2>
    <ul>
        <li class="fragment">Herangehensweise anders als bei Java / .NET
        <li class="fragment">Vieles muss man sich selbst erarbeiten
        <li class="fragment">Es gibt wenige echte Standards
        <li class="fragment">Die meisten Entscheidungen muss man selbst treffen (und verantworten)
        <li class="fragment">Langlebigkeit von Bibliotheken teilweise fraglich
        <li class="fragment">Einstieg daher oft mit Angst und Unsicherheit verbunden
    </ul>
</section>

<section>
    <img src="Signierstunde_Oliver_Zeigermann_JAX.png">
</section>

<section>
    <h1>Vielen Dank</h1>

    <h3>Fragen / Diskussion</h3>

    <p>
        <small><a href="http://zeigermann.eu">Oliver Zeigermann</a> / <a href="http://twitter.com/djcordhose">@DJCordhose</a>
        </small>
    </p>
</section>
</div>

</div>

<script src="../reveal.js/lib/js/head.min.js"></script>
<script src="../reveal.js/js/reveal.min.js"></script>

<script>

    // Full list of configuration options available here:
    // https://github.com/hakimel/../reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/none

        // Optional libraries used to extend on ../reveal.js
        dependencies: [
            { src: '../reveal.js/lib/js/classList.js', condition: function () {
                return !document.body.classList;
            } },
            { src: '../reveal.js/plugin/markdown/showdown.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            } },
            { src: '../reveal.js/plugin/markdown/markdown.js', condition: function () {
                return !!document.querySelector('[data-markdown]');
            } },
            { src: '../reveal.js/plugin/highlight/highlight.js', async: true, callback: function () {
                hljs.initHighlightingOnLoad();
            } },
            { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function () {
                return !!document.body.classList;
            } },
            { src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function () {
                return !!document.body.classList;
            } }
            // { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
    });

</script>

</body>
</html>
